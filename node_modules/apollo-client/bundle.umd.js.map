{"version":3,"file":"bundle.umd.js","sources":["../src/core/networkStatus.ts","../src/util/Observable.ts","../src/errors/ApolloError.ts","../src/core/types.ts","../src/core/ObservableQuery.ts","../src/scheduler/scheduler.ts","../src/data/mutations.ts","../src/data/queries.ts","../src/core/QueryManager.ts","../src/data/store.ts","../src/version.ts","../src/ApolloClient.ts"],"sourcesContent":["/**\n * The current status of a queryâ€™s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n}\n","import { GraphQLError } from 'graphql';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: GraphQLError[];\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    Object.setPrototypeOf(this, ApolloError.prototype);\n  }\n}\n","import { DocumentNode, GraphQLError } from 'graphql';\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { FetchResult } from 'apollo-link';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n) => void;\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  maybeDeepFreeze,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { ApolloError } from '../errors/ApolloError';\n\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType } from './types';\nimport {\n  ModifiableWatchQueryOptions,\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n  UpdateQueryFn,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: GraphQLError[];\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport interface FetchMoreOptions {\n  updateQuery: (\n    previousQueryResult: { [key: string]: any },\n    options: {\n      fetchMoreResult?: { [key: string]: any };\n      variables: { [key: string]: any };\n    },\n  ) => Object;\n}\n\nexport interface UpdateQueryOptions {\n  variables?: Object;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) =>\n  storeValue &&\n  ((storeValue.graphQLErrors &&\n    storeValue.graphQLErrors.length > 0 &&\n    policy === 'none') ||\n    storeValue.networkError);\n\nexport class ObservableQuery<T> extends Observable<ApolloQueryResult<T>> {\n  public options: WatchQueryOptions;\n  public queryId: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: { [key: string]: any };\n\n  private isCurrentlyPolling: boolean;\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private scheduler: QueryScheduler<any>;\n  private queryManager: QueryManager<any>;\n  private observers: Observer<ApolloQueryResult<T>>[];\n  private subscriptionHandles: Subscription[];\n\n  private lastResult: ApolloQueryResult<T>;\n  private lastError: ApolloError;\n  private lastVariables: { [key: string]: any };\n\n  constructor({\n    scheduler,\n    options,\n    shouldSubscribe = true,\n  }: {\n    scheduler: QueryScheduler<any>;\n    options: WatchQueryOptions;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<T>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isCurrentlyPolling = false;\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || {};\n    this.queryId = scheduler.queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    // related classes\n    this.scheduler = scheduler;\n    this.queryManager = scheduler.queryManager;\n\n    // interal data stores\n    this.observers = [];\n    this.subscriptionHandles = [];\n  }\n\n  public result(): Promise<ApolloQueryResult<T>> {\n    const that = this;\n    return new Promise((resolve, reject) => {\n      let subscription: Subscription;\n      const observer: Observer<ApolloQueryResult<T>> = {\n        next(result) {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          if (!that.observers.some(obs => obs !== observer)) {\n            that.queryManager.removeQuery(that.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error(error) {\n          reject(error);\n        },\n      };\n      subscription = that.subscribe(observer);\n    });\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {result: Object, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public currentResult(): ApolloCurrentResult<T> {\n    if (this.isTornDown) {\n      return {\n        data: this.lastError ? {} : this.lastResult ? this.lastResult.data : {},\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n\n    if (hasError(queryStoreValue, this.options.errorPolicy)) {\n      return {\n        data: {},\n        loading: false,\n        networkStatus: queryStoreValue.networkStatus,\n        error: new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }),\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n\n    const queryLoading =\n      !queryStoreValue ||\n      queryStoreValue.networkStatus === NetworkStatus.loading;\n\n    // We need to be careful about the loading state we show to the user, to try\n    // and be vaguely in line with what the user would have seen from .subscribe()\n    // but to still provide useful information synchronously when the query\n    // will not end up hitting the server.\n    // See more: https://github.com/apollostack/apollo-client/issues/707\n    // Basically: is there a query in flight right now (modolo the next tick)?\n    const loading =\n      (this.options.fetchPolicy === 'network-only' && queryLoading) ||\n      (partial && this.options.fetchPolicy !== 'cache-only');\n\n    // if there is nothing in the query store, it means this query hasn't fired yet or it has been cleaned up. Therefore the\n    // network status is dependent on queryLoading.\n    let networkStatus: NetworkStatus;\n    if (queryStoreValue) {\n      networkStatus = queryStoreValue.networkStatus;\n    } else {\n      networkStatus = loading ? NetworkStatus.loading : NetworkStatus.ready;\n    }\n\n    const result = {\n      data,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<T>;\n\n    if (\n      queryStoreValue &&\n      queryStoreValue.graphQLErrors &&\n      this.options.errorPolicy === 'all'\n    ) {\n      result.errors = queryStoreValue.graphQLErrors;\n    }\n\n    if (!partial) {\n      const stale = false;\n      this.lastResult = { ...result, stale };\n    }\n\n    return { ...result, partial } as ApolloCurrentResult<T>;\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // currentResult! If you're not sure which you need, then you probably need currentResult.\n  public getLastResult(): ApolloQueryResult<T> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public refetch(variables?: any): Promise<ApolloQueryResult<T>> {\n    const { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(\n        new Error(\n          'cache-only fetchPolicy option should not be used together with query refetch.',\n        ),\n      );\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    // Override fetchPolicy for this call only\n    // only network-only and no-cache are safe to use\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    const combinedOptions: WatchQueryOptions = {\n      ...this.options,\n      fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only',\n    };\n\n    return this.queryManager\n      .fetchQuery(this.queryId, combinedOptions, FetchType.refetch)\n      .then(result => maybeDeepFreeze(result));\n  }\n\n  public fetchMore(\n    fetchMoreOptions: FetchMoreQueryOptions & FetchMoreOptions,\n  ): Promise<ApolloQueryResult<T>> {\n    // early return if no update Query\n    if (!fetchMoreOptions.updateQuery) {\n      throw new Error(\n        'updateQuery option is required. This function defines how to update the query data with the new results.',\n      );\n    }\n\n    return Promise.resolve()\n      .then(() => {\n        const qid = this.queryManager.generateQueryId();\n        let combinedOptions: any;\n\n        if (fetchMoreOptions.query) {\n          // fetch a new query\n          combinedOptions = fetchMoreOptions;\n        } else {\n          // fetch the same query with a possibly new variables\n          combinedOptions = {\n            ...this.options,\n            ...fetchMoreOptions,\n            variables: {\n              ...this.variables,\n              ...fetchMoreOptions.variables,\n            },\n          };\n        }\n\n        combinedOptions.fetchPolicy = 'network-only';\n\n        return this.queryManager.fetchQuery(\n          qid,\n          combinedOptions as WatchQueryOptions,\n          FetchType.normal,\n          this.queryId,\n        );\n      })\n      .then(fetchMoreResult => {\n        this.updateQuery(\n          (previousResult: any, { variables }: { [key: string]: any }) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data,\n              variables,\n            }),\n        );\n\n        return fetchMoreResult as ApolloQueryResult<T>;\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore(options: SubscribeToMoreOptions): () => void {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: data => {\n          if (options.updateQuery) {\n            this.updateQuery((previous: Object, { variables }) =>\n              (options.updateQuery as UpdateQueryFn)(previous, {\n                subscriptionData: data,\n                variables,\n              }),\n            );\n          }\n        },\n        error: err => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          console.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptionHandles.push(subscription);\n\n    return () => {\n      const i = this.subscriptionHandles.indexOf(subscription);\n      if (i >= 0) {\n        this.subscriptionHandles.splice(i, 1);\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: ModifiableWatchQueryOptions,\n  ): Promise<ApolloQueryResult<T>> {\n    const oldOptions = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    // If fetchPolicy went from cache-only to something else, or from something else to network-only\n    const tryFetch: boolean =\n      (oldOptions.fetchPolicy !== 'network-only' &&\n        opts.fetchPolicy === 'network-only') ||\n      (oldOptions.fetchPolicy === 'cache-only' &&\n        opts.fetchPolicy !== 'cache-only') ||\n      (oldOptions.fetchPolicy === 'standby' &&\n        opts.fetchPolicy !== 'standby') ||\n      false;\n\n    return this.setVariables(\n      this.options.variables,\n      tryFetch,\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: if the variables have not changed, the promise will return the old\n   * results immediately, and the `next` callback will *not* fire.\n   *\n   * Note: if the query is not active (there are no subscribers), the promise\n   * will return null immediately.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   *\n   */\n  public setVariables(\n    variables: any,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<T>> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    const newVariables = variables\n\n    if (isEqual(newVariables, this.variables) && !tryFetch) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      if (this.observers.length === 0 || !fetchResults) {\n        return new Promise(resolve => resolve());\n      }\n      return this.result();\n    } else {\n      this.lastVariables = this.variables;\n      this.variables = newVariables;\n      this.options.variables = newVariables;\n\n      // See comment above\n      if (this.observers.length === 0) {\n        return new Promise(resolve => resolve());\n      }\n\n      // Use the same options as before, but with new variables\n      return this.queryManager\n        .fetchQuery(this.queryId, {\n          ...this.options,\n          variables: this.variables,\n        } as WatchQueryOptions)\n        .then(result => maybeDeepFreeze(result));\n    }\n  }\n\n  public updateQuery(\n    mapFn: (previousQueryResult: any, options: UpdateQueryOptions) => any,\n  ): void {\n    const {\n      previousResult,\n      variables,\n      document,\n    } = this.queryManager.getQueryWithPreviousResult(this.queryId);\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      this.queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      this.queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.options.pollInterval = undefined;\n      this.isCurrentlyPolling = false;\n    }\n  }\n\n  public startPolling(pollInterval: number) {\n    if (\n      this.options.fetchPolicy === 'cache-first' ||\n      this.options.fetchPolicy === 'cache-only'\n    ) {\n      throw new Error(\n        'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n      );\n    }\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n    this.options.pollInterval = pollInterval;\n    this.isCurrentlyPolling = true;\n    this.scheduler.startPollingQuery(this.options, this.queryId);\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<T>>) {\n    // Zen Observable has its own error function, in order to log correctly\n    // we need to declare a custom error if nothing is passed\n    if (\n      (observer as any)._subscription &&\n      (observer as any)._subscription._observer &&\n      !(observer as any)._subscription._observer.error\n    ) {\n      (observer as any)._subscription._observer.error = (\n        error: ApolloError,\n      ) => {\n        console.error('Unhandled error', error.message, error.stack);\n      };\n    }\n\n    this.observers.push(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (this.observers.length === 1) this.setUpQuery();\n\n    return () => {\n      this.observers = this.observers.filter(obs => obs !== observer);\n\n      if (this.observers.length === 0) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    if (this.shouldSubscribe) {\n      this.queryManager.addObservableQuery<T>(this.queryId, this);\n    }\n\n    if (!!this.options.pollInterval) {\n      if (\n        this.options.fetchPolicy === 'cache-first' ||\n        this.options.fetchPolicy === 'cache-only'\n      ) {\n        throw new Error(\n          'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n        );\n      }\n\n      this.isCurrentlyPolling = true;\n      this.scheduler.startPollingQuery<T>(this.options, this.queryId);\n    }\n\n    const observer: Observer<ApolloQueryResult<T>> = {\n      next: (result: ApolloQueryResult<T>) => {\n        this.lastResult = result;\n        this.observers.forEach(obs => obs.next && obs.next(result));\n      },\n      error: (error: ApolloError) => {\n        this.lastError = error;\n        this.observers.forEach(obs => obs.error && obs.error(error));\n      },\n    };\n\n    this.queryManager.startQuery<T>(\n      this.queryId,\n      this.options,\n      this.queryManager.queryListenerForObserver(\n        this.queryId,\n        this.options,\n        observer,\n      ),\n    );\n  }\n\n  private tearDownQuery() {\n    this.isTornDown = true;\n\n    if (this.isCurrentlyPolling) {\n      this.scheduler.stopPollingQuery(this.queryId);\n      this.isCurrentlyPolling = false;\n    }\n\n    // stop all active GraphQL subscriptions\n    this.subscriptionHandles.forEach(sub => sub.unsubscribe());\n    this.subscriptionHandles = [];\n\n    this.queryManager.removeObservableQuery(this.queryId);\n\n    this.queryManager.stopQuery(this.queryId);\n\n    this.observers = [];\n  }\n}\n","// The QueryScheduler is supposed to be a mechanism that schedules polling queries such that\n// they are clustered into the time slots of the QueryBatcher and are batched together. It\n// also makes sure that for a given polling query, if one instance of the query is inflight,\n// another instance will not be fired until the query returns or times out. We do this because\n// another query fires while one is already in flight, the data will stay in the \"loading\" state\n// even after the first query has returned.\n\n// At the moment, the QueryScheduler implements the one-polling-instance-at-a-time logic and\n// adds queries to the QueryBatcher queue.\n\nimport { QueryManager } from '../core/QueryManager';\n\nimport { FetchType, QueryListener } from '../core/types';\n\nimport { ObservableQuery } from '../core/ObservableQuery';\n\nimport { WatchQueryOptions } from '../core/watchQueryOptions';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport class QueryScheduler<TCacheShape> {\n  // Map going from queryIds to query options that are in flight.\n  public inFlightQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from query ids to the query options associated with those queries. Contains all of\n  // the queries, both in flight and not in flight.\n  public registeredQueries: { [queryId: string]: WatchQueryOptions } = {};\n\n  // Map going from polling interval with to the query ids that fire on that interval.\n  // These query ids are associated with a set of options in the this.registeredQueries.\n  public intervalQueries: { [interval: number]: string[] } = {};\n\n  // We use this instance to actually fire queries (i.e. send them to the batching\n  // mechanism).\n  public queryManager: QueryManager<TCacheShape>;\n\n  // Map going from polling interval widths to polling timers.\n  private pollingTimers: { [interval: number]: any } = {};\n\n  private ssrMode: boolean = false;\n\n  constructor({\n    queryManager,\n    ssrMode,\n  }: {\n    queryManager: QueryManager<TCacheShape>;\n    ssrMode?: boolean;\n  }) {\n    this.queryManager = queryManager;\n    this.ssrMode = ssrMode || false;\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryManager.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType: FetchType,\n  ) {\n    return new Promise((resolve, reject) => {\n      this.queryManager\n        .fetchQuery<T>(queryId, options, fetchType)\n        .then(result => {\n          resolve(result);\n        })\n        .catch(error => {\n          reject(error);\n        });\n    });\n  }\n\n  public startPollingQuery<T>(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    if (!options.pollInterval) {\n      throw new Error(\n        'Attempted to start a polling query without a polling interval.',\n      );\n    }\n\n    // Do not poll in SSR mode\n    if (this.ssrMode) return queryId;\n\n    this.registeredQueries[queryId] = options;\n\n    if (listener) {\n      this.queryManager.addQueryListener(queryId, listener);\n    }\n    this.addQueryOnInterval<T>(queryId, options);\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    // Remove the query options from one of the registered queries.\n    // The polling function will then take care of not firing it anymore.\n    delete this.registeredQueries[queryId];\n  }\n\n  // Fires the all of the queries on a particular interval. Called on a setInterval.\n  public fetchQueriesOnInterval<T>(interval: number) {\n    // XXX this \"filter\" here is nasty, because it does two things at the same time.\n    // 1. remove queries that have stopped polling\n    // 2. call fetchQueries for queries that are polling and not in flight.\n    // TODO: refactor this to make it cleaner\n    this.intervalQueries[interval] = this.intervalQueries[interval].filter(\n      queryId => {\n        // If queryOptions can't be found from registeredQueries or if it has a\n        // different interval, it means that this queryId is no longer registered\n        // and should be removed from the list of queries firing on this interval.\n        //\n        // We don't remove queries from intervalQueries immediately in\n        // stopPollingQuery so that we can keep the timer consistent when queries\n        // are removed and replaced, and to avoid quadratic behavior when stopping\n        // many queries.\n        if (\n          !(\n            this.registeredQueries.hasOwnProperty(queryId) &&\n            this.registeredQueries[queryId].pollInterval === interval\n          )\n        ) {\n          return false;\n        }\n\n        // Don't fire this instance of the polling query is one of the instances is already in\n        // flight.\n        if (this.checkInFlight(queryId)) {\n          return true;\n        }\n\n        const queryOptions = this.registeredQueries[queryId];\n        const pollingOptions = { ...queryOptions } as WatchQueryOptions;\n        pollingOptions.fetchPolicy = 'network-only';\n        // don't let unhandled rejections happen\n        this.fetchQuery<T>(queryId, pollingOptions, FetchType.poll).catch(\n          () => {},\n        );\n        return true;\n      },\n    );\n\n    if (this.intervalQueries[interval].length === 0) {\n      clearInterval(this.pollingTimers[interval]);\n      delete this.intervalQueries[interval];\n    }\n  }\n\n  // Adds a query on a particular interval to this.intervalQueries and then fires\n  // that query with all the other queries executing on that interval. Note that the query id\n  // and query options must have been added to this.registeredQueries before this function is called.\n  public addQueryOnInterval<T>(\n    queryId: string,\n    queryOptions: WatchQueryOptions,\n  ) {\n    const interval = queryOptions.pollInterval;\n\n    if (!interval) {\n      throw new Error(\n        `A poll interval is required to start polling query with id '${queryId}'.`,\n      );\n    }\n\n    // If there are other queries on this interval, this query will just fire with those\n    // and we don't need to create a new timer.\n    if (\n      this.intervalQueries.hasOwnProperty(interval.toString()) &&\n      this.intervalQueries[interval].length > 0\n    ) {\n      this.intervalQueries[interval].push(queryId);\n    } else {\n      this.intervalQueries[interval] = [queryId];\n      // set up the timer for the function that will handle this interval\n      this.pollingTimers[interval] = setInterval(() => {\n        this.fetchQueriesOnInterval<T>(interval);\n      }, interval);\n    }\n  }\n\n  // Used only for unit testing.\n  public registerPollingQuery<T>(\n    queryOptions: WatchQueryOptions,\n  ): ObservableQuery<T> {\n    if (!queryOptions.pollInterval) {\n      throw new Error(\n        'Attempted to register a non-polling query with the scheduler.',\n      );\n    }\n    return new ObservableQuery<T>({\n      scheduler: this,\n      options: queryOptions,\n    });\n  }\n}\n","export class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutationString: string,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutationString: mutationString,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = error;\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n\n    if (!mutation) {\n      return;\n    }\n\n    mutation.loading = false;\n    mutation.error = null;\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutationString: string;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\n\nimport { NetworkStatus } from '../core/networkStatus';\n\nexport type QueryStoreValue = {\n  queryString: string;\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: GraphQLError[];\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    queryString: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    if (previousQuery && previousQuery.queryString !== query.queryString) {\n      // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n      // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n      // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n      throw new Error(\n        'Internal Error: may not update existing query string in store',\n      );\n    }\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: GraphQLError[] = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      queryString: query.queryString,\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (typeof query.fetchMoreForQueryId === 'string') {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors =\n      result.errors && result.errors.length ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    if (!this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = complete\n      ? NetworkStatus.ready\n      : NetworkStatus.loading;\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    // keep only the queries with query ids that are associated with observables\n    this.store = Object.keys(this.store)\n      .filter(queryId => {\n        return observableQueryIds.indexOf(queryId) > -1;\n      })\n      .reduce(\n        (res, key) => {\n          // XXX set loading to true so listeners don't trigger unless they want results with partial data\n          res[key] = {\n            ...this.store[key],\n            networkStatus: NetworkStatus.loading,\n          };\n\n          return res;\n        },\n        {} as { [queryId: string]: QueryStoreValue },\n      );\n  }\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { DedupLink as Deduplicator } from 'apollo-link-dedup';\nimport { Cache } from 'apollo-cache';\nimport {\n  assign,\n  getDefaultValues,\n  getMutationDefinition,\n  getOperationDefinition,\n  getOperationName,\n  getQueryDefinition,\n  isProduction,\n  maybeDeepFreeze,\n  hasDirectives,\n} from 'apollo-utilities';\n\nimport { QueryScheduler } from '../scheduler/scheduler';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\n\nimport { Observer, Subscription, Observable } from '../util/Observable';\n\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { QueryListener, ApolloQueryResult, FetchType } from './types';\nimport { graphQLResultHasError } from 'apollo-utilities';\n\nexport interface QueryInfo {\n  listeners: QueryListener[];\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number | null;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Subscription[];\n  cancel?: (() => void);\n}\n\nconst defaultQueryInfo = {\n  listeners: [],\n  invalidated: false,\n  document: null,\n  newData: null,\n  lastRequestId: null,\n  observableQuery: null,\n  subscriptions: [],\n};\n\nexport interface QueryPromise {\n  promise: Promise<ApolloQueryResult<any>>;\n  resolve: (result: ApolloQueryResult<any>) => void;\n  reject: (error: Error) => void;\n}\n\nexport class QueryManager<TStore> {\n  public scheduler: QueryScheduler<TStore>;\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n\n  private deduplicator: ApolloLink;\n  private queryDeduplication: boolean;\n\n  private onBroadcast: () => void;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map going from a requestId to a promise that has not yet been resolved. We use this to keep\n  // track of queries that are inflight and reject them in case some\n  // destabalizing action occurs (e.g. reset of the Apollo store).\n  private fetchQueryPromises: Map<string, QueryPromise> = new Map();\n\n  // A map going from the name of a query to an observer issued for it by watchQuery. This is\n  // generally used to refetches for refetchQueries and to update mutation results through\n  // updateQueries.\n  private queryIdsByName: { [queryName: string]: string[] } = {};\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n  }) {\n    this.link = link;\n    this.deduplicator = ApolloLink.from([new Deduplicator(), link]);\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n\n    this.scheduler = new QueryScheduler({ queryManager: this, ssrMode });\n  }\n\n  public mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    if (!mutation) {\n      throw new Error(\n        'mutation option is required. You must specify your GraphQL document in the mutation option.',\n      );\n    }\n\n    if (fetchPolicy && fetchPolicy !== 'no-cache') {\n      throw new Error(\n        \"fetchPolicy for mutations currently only supports the 'no-cache' policy\",\n      );\n    }\n\n    const mutationId = this.generateQueryId();\n    const cache = this.dataStore.getCache();\n    (mutation = cache.transformDocument(mutation)),\n      (variables = assign(\n        {},\n        getDefaultValues(getMutationDefinition(mutation)),\n        variables,\n      ));\n    const mutationString = print(mutation);\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        Object.keys(updateQueriesByName).forEach(queryName =>\n          (this.queryIdsByName[queryName] || []).forEach(queryId => {\n            ret[queryId] = {\n              updater: updateQueriesByName[queryName],\n              query: this.queryStore.get(queryId),\n            };\n          }),\n        );\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(mutationId, mutationString, variables);\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables: variables || {},\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      const operation = this.buildOperationForLink(mutation, variables, {\n        ...context,\n        optimisticResponse,\n      });\n      execute(this.link, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          this.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            this.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables: variables || {},\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n          storeResult = result as FetchResult<T>;\n        },\n        error: (err: Error) => {\n          this.mutationStore.markMutationError(mutationId, err);\n          this.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          this.broadcastQueries();\n\n          this.setQuery(mutationId, () => ({ document: undefined }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n        complete: () => {\n          if (error) {\n            this.mutationStore.markMutationError(mutationId, error);\n          }\n\n          this.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          this.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function')\n            refetchQueries = refetchQueries(storeResult as ExecutionResult);\n\n          refetchQueries.forEach(refetchQuery => {\n            if (typeof refetchQuery === 'string') {\n              this.refetchQueryByName(refetchQuery);\n              return;\n            }\n\n            this.query({\n              query: refetchQuery.query,\n              variables: refetchQuery.variables,\n              fetchPolicy: 'network-only',\n            });\n          });\n          this.setQuery(mutationId, () => ({ document: undefined }));\n          if (\n            errorPolicy === 'ignore' &&\n            storeResult &&\n            graphQLResultHasError(storeResult)\n          ) {\n            delete storeResult.errors;\n          }\n          resolve(storeResult as FetchResult<T>);\n        },\n      });\n    });\n  }\n\n  public fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      variables = {},\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n    } = options;\n    const cache = this.dataStore.getCache();\n\n    const query = cache.transformDocument(options.query);\n\n    let storeResult: any;\n    let needToFetch: boolean =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    // If this is not a force fetch, we want to diff the query against the\n    // store before we fetch it from the network interface.\n    // TODO we hit the cache even if the policy is network-first. This could be unnecessary if the network is up.\n    if (\n      fetchType !== FetchType.refetch &&\n      fetchPolicy !== 'network-only' &&\n      fetchPolicy !== 'no-cache'\n    ) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.generateRequestId();\n\n    // set up a watcher to listen to cache updates\n    const cancel = this.updateQueryWatch(queryId, query, options);\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(true, fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      queryString: print(query),\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    const shouldDispatchClientResult =\n      !shouldFetch || fetchPolicy === 'cache-and-network';\n\n    if (shouldDispatchClientResult) {\n      this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n\n      this.invalidate(true, queryId, fetchMoreForQueryId);\n\n      this.broadcastQueries();\n    }\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          this.removeFetchQueryPromise(requestId);\n\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      } else {\n        // however we need to catch the error so it isn't unhandled in case of\n        // network error\n        networkResult.catch(() => {});\n      }\n    }\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return Promise.resolve<ExecutionResult>({ data: storeResult });\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    let previouslyHadError: boolean = false;\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(false, queryId);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const errorPolicy = observableQuery\n        ? observableQuery.options.errorPolicy\n        : options.errorPolicy;\n\n      const lastResult = observableQuery\n        ? observableQuery.getLastResult()\n        : null;\n\n      const lastError = observableQuery ? observableQuery.getLastError() : null;\n\n      let shouldNotifyIfLoading =\n        (!newData && queryStoreValue.previousVariables != null) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      // if this caused by a cache broadcast but the query is still in flight\n      // don't notify the observer\n      // if (\n      //   isCacheBroadcast &&\n      //   isNetworkRequestInFlight(queryStoreValue.networkStatus)\n      // ) {\n      //   shouldNotifyIfLoading = false;\n      // }\n\n      const networkStatusChanged = Boolean(\n        lastResult &&\n          queryStoreValue.networkStatus !== lastResult.networkStatus,\n      );\n\n      const errorStatusChanged =\n        errorPolicy &&\n        (lastError && lastError.graphQLErrors) !==\n          queryStoreValue.graphQLErrors &&\n        errorPolicy !== 'none';\n\n      if (\n        !isNetworkRequestInFlight(queryStoreValue.networkStatus) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        shouldNotifyIfLoading\n      ) {\n        // If we have either a GraphQL error or a network error, we create\n        // an error and tell the observer about it.\n        if (\n          ((!errorPolicy || errorPolicy === 'none') &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0) ||\n          queryStoreValue.networkError\n        ) {\n          const apolloError = new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          });\n          previouslyHadError = true;\n          if (observer.error) {\n            try {\n              observer.error(apolloError);\n            } catch (e) {\n              // Throw error outside this control flow to avoid breaking Apollo's state\n              setTimeout(() => {\n                throw e;\n              }, 0);\n            }\n          } else {\n            // Throw error outside this control flow to avoid breaking Apollo's state\n            setTimeout(() => {\n              throw apolloError;\n            }, 0);\n            if (!isProduction()) {\n              /* tslint:disable-next-line */\n              console.info(\n                'An unhandled error was thrown because no error handler is registered ' +\n                  'for the query ' +\n                  queryStoreValue.queryString,\n              );\n            }\n          }\n          return;\n        }\n\n        try {\n          let data: any;\n          let isMissing: boolean;\n\n          if (newData) {\n            // clear out the latest new data, since we're now using it\n            this.setQuery(queryId, () => ({ newData: null }));\n\n            data = newData.result;\n            isMissing = !newData.complete ? !newData.complete : false;\n          } else {\n            if (lastResult && lastResult.data && !errorStatusChanged) {\n              data = lastResult.data;\n              isMissing = false;\n            } else {\n              const { document } = this.getQuery(queryId);\n              const readResult = this.dataStore.getCache().diff({\n                query: document as DocumentNode,\n                variables:\n                  queryStoreValue.previousVariables ||\n                  queryStoreValue.variables,\n                optimistic: true,\n              });\n\n              data = readResult.result;\n              isMissing = !readResult.complete;\n            }\n          }\n\n          let resultFromStore: ApolloQueryResult<T>;\n\n          // If there is some data missing and the user has told us that they\n          // do not tolerate partial data then we want to return the previous\n          // result and mark it as stale.\n          if (isMissing && fetchPolicy !== 'cache-only') {\n            resultFromStore = {\n              data: lastResult && lastResult.data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: true,\n            };\n          } else {\n            resultFromStore = {\n              data,\n              loading: isNetworkRequestInFlight(queryStoreValue.networkStatus),\n              networkStatus: queryStoreValue.networkStatus,\n              stale: false,\n            };\n          }\n\n          // if the query wants updates on errors we need to add it to the result\n          if (\n            errorPolicy === 'all' &&\n            queryStoreValue.graphQLErrors &&\n            queryStoreValue.graphQLErrors.length > 0\n          ) {\n            resultFromStore.errors = queryStoreValue.graphQLErrors;\n          }\n\n          if (observer.next) {\n            const isDifferentResult = !(\n              lastResult &&\n              resultFromStore &&\n              lastResult.networkStatus === resultFromStore.networkStatus &&\n              lastResult.stale === resultFromStore.stale &&\n              // We can do a strict equality check here because we include a `previousResult`\n              // with `readQueryFromStore`. So if the results are the same they will be\n              // referentially equal.\n              lastResult.data === resultFromStore.data\n            );\n\n            if (isDifferentResult || previouslyHadError) {\n              try {\n                observer.next(maybeDeepFreeze(resultFromStore));\n              } catch (e) {\n                // Throw error outside this control flow to avoid breaking Apollo's state\n                setTimeout(() => {\n                  throw e;\n                }, 0);\n              }\n            }\n          }\n          previouslyHadError = false;\n        } catch (error) {\n          previouslyHadError = true;\n          if (observer.error)\n            observer.error(new ApolloError({ networkError: error }));\n          return;\n        }\n      }\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T> {\n    if (options.fetchPolicy === 'standby') {\n      throw new Error(\n        'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n      );\n    }\n\n    // get errors synchronously\n    const queryDefinition = getQueryDefinition(options.query);\n\n    // assign variable default values if supplied\n    if (\n      queryDefinition.variableDefinitions &&\n      queryDefinition.variableDefinitions.length\n    ) {\n      const defaultValues = getDefaultValues(queryDefinition);\n\n      options.variables = assign({}, defaultValues, options.variables);\n    }\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions;\n\n    return new ObservableQuery<T>({\n      scheduler: this.scheduler,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: WatchQueryOptions): Promise<ApolloQueryResult<T>> {\n    if (!options.query) {\n      throw new Error(\n        'query option is required. You must specify your GraphQL document in the query option.',\n      );\n    }\n\n    if (options.query.kind !== 'Document') {\n      throw new Error('You must wrap the query string in a \"gql\" tag.');\n    }\n\n    if ((options as any).returnPartialData) {\n      throw new Error('returnPartialData option only supported on watchQuery.');\n    }\n\n    if ((options as any).pollInterval) {\n      throw new Error('pollInterval option only supported on watchQuery.');\n    }\n\n    if (typeof options.notifyOnNetworkStatusChange !== 'undefined') {\n      throw new Error(\n        'Cannot call \"query\" with \"notifyOnNetworkStatusChange\" option. Only \"watchQuery\" has that option.',\n      );\n    }\n    options.notifyOnNetworkStatusChange = false;\n\n    const requestId = this.idCounter;\n    const resPromise = new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, resPromise, resolve, reject);\n\n      return this.watchQuery<T>(options, false)\n        .result()\n        .then(result => {\n          this.removeFetchQueryPromise(requestId);\n          resolve(result);\n        })\n        .catch(error => {\n          this.removeFetchQueryPromise(requestId);\n          reject(error);\n        });\n    });\n\n    return resPromise;\n  }\n\n  public generateQueryId() {\n    const queryId = this.idCounter.toString();\n    this.idCounter++;\n    return queryId;\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(true, queryId);\n    this.broadcastQueries();\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners = [] }) => ({\n      listeners: listeners.concat([listener]),\n      invalidate: false,\n    }));\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: (newData: ApolloQueryResult<any>) => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds a promise to this.fetchQueryPromises for a given request ID.\n  public addFetchQueryPromise<T>(\n    requestId: number,\n    promise: Promise<ApolloQueryResult<T>>,\n    resolve: (result: ApolloQueryResult<T>) => void,\n    reject: (error: Error) => void,\n  ) {\n    this.fetchQueryPromises.set(requestId.toString(), {\n      promise,\n      resolve,\n      reject,\n    });\n  }\n\n  // Removes the promise in this.fetchQueryPromises for a particular request ID.\n  public removeFetchQueryPromise(requestId: number) {\n    this.fetchQueryPromises.delete(requestId.toString());\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n\n    // Insert the ObservableQuery into this.observableQueriesByName if the query has a name\n    const queryDef = getQueryDefinition(observableQuery.options.query);\n    if (queryDef.name && queryDef.name.value) {\n      const queryName = queryDef.name.value;\n\n      // XXX we may we want to warn the user about query name conflicts in the future\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];\n      this.queryIdsByName[queryName].push(observableQuery.queryId);\n    }\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { observableQuery, cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    if (!observableQuery) return;\n\n    const definition = getQueryDefinition(observableQuery.options.query);\n    const queryName = definition.name ? definition.name.value : null;\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (queryName) {\n      this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(\n        val => {\n          return !(observableQuery.queryId === val);\n        },\n      );\n    }\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryPromises.forEach(({ reject }) => {\n      reject(\n        new Error(\n          'Store reset while query was in flight(not completed in link chain)',\n        ),\n      );\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    const reset = this.dataStore.reset();\n    return reset;\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  private getObservableQueryPromises(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>>[] {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (!observableQuery) return;\n      const fetchPolicy = observableQuery.options.fetchPolicy;\n\n      observableQuery.resetLastResults();\n      if (\n        fetchPolicy !== 'cache-only' &&\n        (includeStandby || fetchPolicy !== 'standby')\n      ) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n\n      this.setQuery(queryId, () => ({ newData: null }));\n      this.invalidate(true, queryId);\n    });\n\n    return observableQueryPromises;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<\n      ApolloQueryResult<any>\n    >[] = this.getObservableQueryPromises(includeStandby);\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription(\n    options: SubscriptionOptions,\n  ): Observable<any> {\n    const { query } = options;\n    const cache = this.dataStore.getCache();\n    let transformedDoc = cache.transformDocument(query);\n\n    const variables = assign(\n      {},\n      getDefaultValues(getOperationDefinition(query)),\n      options.variables,\n    );\n\n    let sub: Subscription;\n    let observers: Observer<any>[] = [];\n\n    return new Observable(observer => {\n      observers.push(observer);\n\n      // If this is the first observer, actually initiate the network subscription\n      if (observers.length === 1) {\n        const handler = {\n          next: (result: FetchResult) => {\n            this.dataStore.markSubscriptionResult(\n              result,\n              transformedDoc,\n              variables,\n            );\n            this.broadcastQueries();\n\n            // It's slightly awkward that the data for subscriptions doesn't come from the store.\n            observers.forEach(obs => {\n              // XXX I'd prefer a different way to handle errors for subscriptions\n              if (obs.next) obs.next(result);\n            });\n          },\n          error: (error: Error) => {\n            observers.forEach(obs => {\n              if (obs.error) obs.error(error);\n            });\n          },\n        };\n\n        // TODO: Should subscriptions also accept a `context` option to pass\n        // through to links?\n        const operation = this.buildOperationForLink(transformedDoc, variables);\n        sub = execute(this.link, operation).subscribe(handler);\n      }\n\n      return () => {\n        observers = observers.filter(obs => obs !== observer);\n\n        // If we removed the last observer, tear down the network subscription\n        if (observers.length === 0 && sub) {\n          sub.unsubscribe();\n        }\n      };\n    });\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryInStore(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    const { subscriptions } = this.getQuery(queryId);\n    // teardown all links\n    subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ) {\n    const { variables, query } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n    // XXX test this\n    if (newData) {\n      return maybeDeepFreeze({ data: newData.result, partial: false });\n    } else {\n      try {\n        // the query is brand new, so we read from the store to see if anything is there\n        const data = this.dataStore.getCache().read({\n          query,\n          variables,\n          previousResult: lastResult ? lastResult.data : undefined,\n          optimistic,\n        });\n\n        return maybeDeepFreeze({ data, partial: false });\n      } catch (e) {\n        return maybeDeepFreeze({ data: {}, partial: true });\n      }\n    }\n  }\n\n  public getQueryWithPreviousResult<T>(\n    queryIdOrObservable: string | ObservableQuery<T>,\n  ) {\n    let observableQuery: ObservableQuery<T>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      if (!foundObserveableQuery) {\n        throw new Error(\n          `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`,\n        );\n      }\n      observableQuery = foundObserveableQuery;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n\n    const { data } = this.getCurrentQueryResult(observableQuery, false);\n\n    return {\n      previousResult: data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (!info.invalidated || !info.listeners) return;\n      info.listeners\n        // it's possible for the listener to be undefined if the query is being stopped\n        // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n        .filter((x: QueryListener) => !!x)\n        .forEach((listener: QueryListener) => {\n          listener(this.queryStore.get(id), info.newData);\n        });\n    });\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<ExecutionResult> {\n    const { variables, context, errorPolicy = 'none', fetchPolicy } = options;\n    const operation = this.buildOperationForLink(document, variables, {\n      ...context,\n      // TODO: Should this be included for all entry points via\n      // buildOperationForLink?\n      forceFetch: !this.queryDeduplication,\n    });\n\n    let resultFromStore: any;\n    let errorsFromStore: any;\n    const retPromise = new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      this.addFetchQueryPromise<T>(requestId, retPromise, resolve, reject);\n      const subscription = execute(this.deduplicator, operation).subscribe({\n        next: (result: ExecutionResult) => {\n          // default the lastRequestId to 1\n          const { lastRequestId } = this.getQuery(queryId);\n          if (requestId >= (lastRequestId || 1)) {\n            if (fetchPolicy !== 'no-cache') {\n              try {\n                this.dataStore.markQueryResult(\n                  result,\n                  document,\n                  variables,\n                  fetchMoreForQueryId,\n                  errorPolicy === 'ignore' || errorPolicy === 'all',\n                );\n              } catch (e) {\n                reject(e);\n                return;\n              }\n            } else {\n              this.setQuery(queryId, () => ({\n                newData: { result: result.data, complete: true },\n              }));\n            }\n\n            this.queryStore.markQueryResult(\n              queryId,\n              result,\n              fetchMoreForQueryId,\n            );\n\n            this.invalidate(true, queryId, fetchMoreForQueryId);\n\n            this.broadcastQueries();\n          }\n\n          if (result.errors && errorPolicy === 'none') {\n            reject(\n              new ApolloError({\n                graphQLErrors: result.errors,\n              }),\n            );\n            return;\n          } else if (errorPolicy === 'all') {\n            errorsFromStore = result.errors;\n          }\n\n          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n            // We don't write fetchMore results to the store because this would overwrite\n            // the original result in case an @connection directive is used.\n            resultFromStore = result.data;\n          } else {\n            try {\n              // ensure result is combined with data already in store\n              resultFromStore = this.dataStore.getCache().read({\n                variables,\n                query: document,\n                optimistic: false,\n              });\n              // this will throw an error if there are missing fields in\n              // the results which can happen with errors from the server.\n              // tslint:disable-next-line\n            } catch (e) {}\n          }\n        },\n        error: (error: ApolloError) => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          reject(error);\n        },\n        complete: () => {\n          this.removeFetchQueryPromise(requestId);\n          this.setQuery(queryId, ({ subscriptions }) => ({\n            subscriptions: subscriptions.filter(x => x !== subscription),\n          }));\n\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => ({\n        subscriptions: subscriptions.concat([subscription]),\n      }));\n    });\n\n    return retPromise;\n  }\n\n  // Refetches a query given that query's name. Refetches\n  // all ObservableQuery instances associated with the query name.\n  private refetchQueryByName(queryName: string) {\n    const refetchedQueries = this.queryIdsByName[queryName];\n    // early return if the query named does not exist (not yet fetched)\n    // this used to warn but it may be inteneded behavoir to try and refetch\n    // un called queries because they could be on different routes\n    if (refetchedQueries === undefined) return;\n    return Promise.all(\n      refetchedQueries\n        .map(id => this.getQuery(id).observableQuery)\n        .filter(x => !!x)\n        .map((x: ObservableQuery<any>) => x.refetch()),\n    );\n  }\n\n  private generateRequestId() {\n    const requestId = this.idCounter;\n    this.idCounter++;\n    return requestId;\n  }\n\n  private getQuery(queryId: string) {\n    return this.queries.get(queryId) || { ...defaultQueryInfo };\n  }\n\n  private setQuery(queryId: string, updater: (prev: QueryInfo) => any) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    invalidated: boolean,\n    queryId?: string,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (queryId) this.setQuery(queryId, () => ({ invalidated }));\n\n    if (fetchMoreForQueryId) {\n      this.setQuery(fetchMoreForQueryId, () => ({ invalidated }));\n    }\n  }\n\n  private buildOperationForLink(\n    document: DocumentNode,\n    variables: any,\n    extraContext?: any,\n  ) {\n    const cache = this.dataStore.getCache();\n\n    return {\n      query: cache.transformForLink\n        ? cache.transformForLink(document)\n        : document,\n      variables,\n      operationName: getOperationName(document) || undefined,\n      context: {\n        ...extraContext,\n        cache,\n        // getting an entry's cache key is useful for cacheResolvers & state-link\n        getCacheKey: (obj: { __typename: string; id: string | number }) => {\n          if ((cache as any).config) {\n            // on the link, we just want the id string, not the full id value from toIdValue\n            return (cache as any).config.dataIdFromObject(obj);\n          } else {\n            throw new Error(\n              'To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.',\n            );\n          }\n        },\n      },\n    };\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      const changeFn = () => {\n        this.markMutationResult({\n          mutationId: mutation.mutationId,\n          result: { data: optimistic },\n          document: mutation.document,\n          variables: mutation.variables,\n          updateQueries: mutation.updateQueries,\n          update: mutation.update,\n        });\n      };\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          changeFn();\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [];\n      cacheWrites.push({\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      });\n\n      if (mutation.updateQueries) {\n        Object.keys(mutation.updateQueries)\n          .filter(id => mutation.updateQueries[id])\n          .forEach(queryId => {\n            const { query, updater } = mutation.updateQueries[queryId];\n            // Read the current query result from the store.\n            const { result: currentQueryResult, complete } = this.cache.diff({\n              query: query.document,\n              variables: query.variables,\n              returnPartialData: true,\n              optimistic: false,\n            });\n\n            if (!complete) {\n              return;\n            }\n\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n      });\n\n      // If the mutation has some writes associated with it then we need to\n      // apply those writes to the store by running this reducer again with a\n      // write action.\n      const update = mutation.update;\n      if (update) {\n        this.cache.performTransaction(c => {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        });\n      }\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (!optimisticResponse) return;\n    this.cache.removeOptimistic(mutationId);\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.2.8\"","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\nimport {\n  isProduction,\n  removeConnectionDirectiveFromDocument,\n} from 'apollo-utilities';\n\nimport { QueryManager } from './core/QueryManager';\nimport { ApolloQueryResult } from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\n\nimport { Observable } from './util/Observable';\n\nimport {\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ModifiableWatchQueryOptions,\n  MutationBaseOptions,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: ModifiableWatchQueryOptions;\n  query?: ModifiableWatchQueryOptions;\n  mutate?: MutationBaseOptions;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrMode?: boolean;\n  ssrForceFetchDelay?: number;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n};\n\nconst supportedDirectives = new ApolloLink(\n  (operation: Operation, forward: NextLink) => {\n    operation.query = removeConnectionDirectiveFromDocument(operation.query);\n    return forward(operation);\n  },\n);\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n\n  private devToolsHookCb: Function;\n  private proxy: ApolloCache<TCacheShape> | undefined;\n  private ssrMode: boolean;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   */\n\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      link,\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n    } = options;\n\n    if (!link || !cache) {\n      throw new Error(`\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      `);\n    }\n\n    // remove apollo-client supported directives\n    this.link = supportedDirectives.concat(link);\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.ssrMode = ssrMode;\n    this.defaultOptions = defaultOptions || {};\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      !isProduction() &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && !isProduction()) {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (window.navigator && window.navigator.userAgent.indexOf('Chrome') > -1) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n    this.version = version;\n  }\n  /**\n   * This watches the results of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches an person's\n   * first name and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and his/her first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   *\n   */\n  public watchQuery<T>(options: WatchQueryOptions): ObservableQuery<T> {\n    this.initQueryManager();\n\n    if (this.defaultOptions.watchQuery) {\n      options = { ...this.defaultOptions.watchQuery, ...options };\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' } as WatchQueryOptions;\n    }\n\n    return this.queryManager.watchQuery<T>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected\n   * with an error.\n   *\n   * @param options An object of type {@link WatchQueryOptions} that allows us to describe\n   * how this query should be treated e.g. whether it is a polling query, whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T>(options: WatchQueryOptions): Promise<ApolloQueryResult<T>> {\n    this.initQueryManager();\n\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options };\n    }\n\n    if (options.fetchPolicy === 'cache-and-network') {\n      throw new Error(\n        'cache-and-network fetchPolicy can only be used with watchQuery',\n      );\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' } as WatchQueryOptions;\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T>(options: MutationOptions<T>): Promise<FetchResult<T>> {\n    this.initQueryManager();\n\n    if (this.defaultOptions.mutate) {\n      options = { ...this.defaultOptions.mutate, ...options };\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T=any>(options: SubscriptionOptions): Observable<T> {\n    this.initQueryManager();\n\n    return this.queryManager.startGraphQLSubscription(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   */\n  public readQuery<T>(options: DataProxy.Query): T | null {\n    return this.initProxy().readQuery<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public readFragment<T>(options: DataProxy.Fragment): T | null {\n    return this.initProxy().readFragment<T>(options);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery(options: DataProxy.WriteQueryOptions): void {\n    const result = this.initProxy().writeQuery(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment(options: DataProxy.WriteFragmentOptions): void {\n    const result = this.initProxy().writeFragment(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData(options: DataProxy.WriteDataOptions): void {\n    const result = this.initProxy().writeData(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager() {\n    if (this.queryManager) return;\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication: this.queryDeduplication,\n      ssrMode: this.ssrMode,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => {\n        return this.queryManager\n          ? this.queryManager.clearStore()\n          : Promise.resolve(null);\n      })\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => {\n        return this.queryManager\n          ? this.queryManager.reFetchObservableQueries()\n          : Promise.resolve(null);\n      });\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed with the store is reset.\n   * onResetStore returns an unsubscribe function for removing your registered callbacks.\n   */\n\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> | Promise<null> {\n    return this.queryManager\n      ? this.queryManager.reFetchObservableQueries(includeStandby)\n      : Promise.resolve(null);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.initProxy().extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.initProxy().restore(serializedState);\n  }\n\n  /**\n   * Initializes a data proxy for this client instance if one does not already\n   * exist and returns either a previously initialized proxy instance or the\n   * newly initialized instance.\n   */\n  private initProxy(): ApolloCache<TCacheShape> {\n    if (!this.proxy) {\n      this.initQueryManager();\n      this.proxy = this.cache;\n    }\n    return this.proxy;\n  }\n}\n"],"names":["NetworkStatus","LinkObservable","__extends","FetchType","isEqual","maybeDeepFreeze","tryFunctionOrLogError","__assign","ApolloLink","Deduplicator","assign","getDefaultValues","getMutationDefinition","print","execute","graphQLResultHasError","hasDirectives","isProduction","getQueryDefinition","getOperationDefinition","getOperationName","removeConnectionDirectiveFromDocument"],"mappings":"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"}