"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("path");
const ts = require("typescript");
const commentsJson = require("comment-json");
const findUp = require("find-up");
const fs_1 = require("../utils/fs");
const configCache = {};
function loadConfiguration(path) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cached = Object.keys(configCache).find(cachePath => path.indexOf(cachePath) === 0);
        if (cached) {
            return configCache[cached];
        }
        const cwd = path_1.dirname(path);
        const configPath = yield findUp('tsconfig.json', { cwd });
        if (!configPath) {
            throw new Error('Cannot find tsconfig');
        }
        const tsconfig = configPath && commentsJson.parse(yield fs_1.readFile(configPath));
        // TODO: use the ParsedCommandLine for the type roots
        const { typeRoots } = tsconfig;
        if (typeRoots && Array.isArray(typeRoots)) {
            tsconfig.include = [
                ...(tsconfig.include || []),
                ...typeRoots.map((root) => `${root.replace(/(\/|\\)*$/, '')}/**/*`)
            ];
        }
        const config = Object.assign({}, ts.parseJsonConfigFileContent(tsconfig, ts.sys, path_1.dirname(configPath)), { path: configPath });
        let { options } = config;
        config.options = options = Object.assign({ module: ts.ModuleKind.CommonJS, moduleResolution: ts.ModuleResolutionKind.NodeJs }, options, { noEmit: false, outDir: undefined });
        configCache[path_1.dirname(configPath)] = config;
        return config;
    });
}
exports.loadConfiguration = loadConfiguration;
//# sourceMappingURL=config-loader.js.map