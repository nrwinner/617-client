{"version":3,"file":"bundle.umd.js","sources":["../src/fragmentMatcher.ts","../src/objectCache.ts","../src/writeToStore.ts","../src/readFromStore.ts","../src/recordingCache.ts","../src/inMemoryCache.ts"],"sourcesContent":["import { isTest, warnOnceInDevelopment, IdValue } from 'apollo-utilities';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean {\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      if (!haveWarned) {\n        console.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        console.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        console.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n\n        /* istanbul ignore if */\n        if (!isTest()) {\n          // When running tests, we want to print the warning every time\n          haveWarned = true;\n        }\n      }\n\n      context.returnPartialData = true;\n      return true;\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    // XXX here we reach an issue - we don't know if this fragment should match or not. It's either:\n    // 1. A fragment on a non-matching concrete type or interface or union\n    // 2. A fragment on a matching interface or union\n    // If it's 1, we don't want to return anything, if it's 2 we want to match. We can't tell the\n    // difference, so we warn the user, but still try to match it (backcompat).\n    warnOnceInDevelopment(\n      `You are using the simple (heuristic) fragment matcher, but your queries contain union or interface types.\n     Apollo Client will not be able to able to accurately map fragments.` +\n        `To make this error go away, use the IntrospectionFragmentMatcher as described in the docs: ` +\n        `https://www.apollographql.com/docs/react/recipes/fragment-matching.html`,\n      'error',\n    );\n\n    context.returnPartialData = true;\n    return true;\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    if (!this.isReady) {\n      // this should basically never happen in proper use.\n      throw new Error(\n        'FragmentMatcher.match() was called before FragmentMatcher.init()',\n      );\n    }\n\n    const obj = context.store.get(idValue.id);\n\n    if (!obj) {\n      return false;\n    }\n\n    if (!obj.__typename) {\n      throw new Error(\n        `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n          obj,\n        )}`,\n      );\n    }\n\n    if (obj.__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(private data: NormalizedCacheObject = {}) {}\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n  public get(dataId: string): StoreObject {\n    return this.data[dataId];\n  }\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n  public delete(dataId: string): void {\n    this.data[dataId] = undefined;\n  }\n  public clear(): void {\n    this.data = {};\n  }\n  public replace(newData: NormalizedCacheObject): void {\n    this.data = newData || {};\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { print } from 'graphql/language/printer';\nimport { FragmentMatcher } from 'graphql-anywhere';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  getQueryDefinition,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { defaultNormalizedCacheFactory, ObjectCache } from './objectCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  NormalizedCacheFactory,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${print(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\n/**\n * Writes the result of a query to the store.\n *\n * @param result The result object returned for the query document.\n *\n * @param query The query document whose result we are writing to the store.\n *\n * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n *\n * @param variables A map from the name of a variable to its value. These variables can be\n * referenced by the query document.\n *\n * @param dataIdFromObject A function that returns an object identifier given a particular result\n * object. See the store documentation for details and an example of this function.\n *\n * @param fragmentMap A map from the name of a fragment to its fragment definition. These fragments\n * can be referenced within the query document.\n *\n * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n */\nexport function writeQueryToStore({\n  result,\n  query,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMap = {} as FragmentMap,\n  fragmentMatcherFunction,\n}: {\n  result: Object;\n  query: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  const queryDefinition: OperationDefinitionNode = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      selectionSet: queryDefinition.selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, query);\n  }\n}\n\nexport type WriteContext = {\n  store: NormalizedCache;\n  storeFactory: NormalizedCacheFactory;\n  processedData?: { [x: string]: FieldNode[] };\n  variables?: any;\n  dataIdFromObject?: IdGetter;\n  fragmentMap?: FragmentMap;\n  fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport function writeResultToStore({\n  dataId,\n  result,\n  document,\n  storeFactory = defaultNormalizedCacheFactory,\n  store = storeFactory(),\n  variables,\n  dataIdFromObject,\n  fragmentMatcherFunction,\n}: {\n  dataId: string;\n  result: any;\n  document: DocumentNode;\n  store?: NormalizedCache;\n  storeFactory?: NormalizedCacheFactory;\n  variables?: Object;\n  dataIdFromObject?: IdGetter;\n  fragmentMatcherFunction?: FragmentMatcher;\n}): NormalizedCache {\n  // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n  const operationDefinition = getOperationDefinition(document);\n  const selectionSet = operationDefinition.selectionSet;\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n\n  variables = assign({}, getDefaultValues(operationDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      result,\n      dataId,\n      selectionSet,\n      context: {\n        store,\n        storeFactory,\n        processedData: {},\n        variables,\n        dataIdFromObject,\n        fragmentMap,\n        fragmentMatcherFunction,\n      },\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, document);\n  }\n}\n\nexport function writeSelectionSetToStore({\n  result,\n  dataId,\n  selectionSet,\n  context,\n}: {\n  dataId: string;\n  result: any;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n}): NormalizedCache {\n  const { variables, store, fragmentMap } = context;\n\n  selectionSet.selections.forEach(selection => {\n    const included = shouldInclude(selection, variables);\n\n    if (isField(selection)) {\n      const resultFieldKey: string = resultKeyNameFromField(selection);\n      const value: any = result[resultFieldKey];\n\n      if (included) {\n        if (typeof value !== 'undefined') {\n          writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          // if this is a defered field we don't need to throw / wanr\n          const isDefered =\n            selection.directives &&\n            selection.directives.length &&\n            selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\n                `Missing field ${resultFieldKey} in ${JSON.stringify(\n                  result,\n                  null,\n                  2,\n                ).substring(0, 100)}`,\n              );\n            }\n          }\n        }\n      }\n    } else {\n      // This is not a field, so it must be a fragment, either inline or named\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // Named fragment\n        fragment = (fragmentMap || {})[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(`No fragment named ${selection.name.value}.`);\n        }\n      }\n\n      let matches = true;\n      if (context.fragmentMatcherFunction && fragment.typeCondition) {\n        // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n        // Right now we have to pretend that we're passing in an idValue and that there's a store\n        // on the context.\n        const idValue = toIdValue({ id: 'self', typename: undefined });\n        const fakeContext: ReadStoreContext = {\n          // NOTE: fakeContext always uses ObjectCache\n          // since this is only to ensure the return value of 'matches'\n          store: new ObjectCache({ self: result }),\n          returnPartialData: false,\n          hasMissingField: false,\n          cacheRedirects: {},\n        };\n        matches = context.fragmentMatcherFunction(\n          idValue,\n          fragment.typeCondition.name.value,\n          fakeContext,\n        );\n        if (!isProduction() && fakeContext.returnPartialData) {\n          console.error('WARNING: heuristic fragment matching going on!');\n        }\n      }\n\n      if (included && matches) {\n        writeSelectionSetToStore({\n          result,\n          selectionSet: fragment.selectionSet,\n          dataId,\n          context,\n        });\n      }\n    }\n  });\n\n  return store;\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n) {\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue)) {\n      mergeWithGenerated(value.id, realValue.id, cache);\n    }\n    cache.delete(generatedKey);\n    cache.set(realKey, { ...generated, ...real } as StoreObject);\n  });\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n\nfunction writeFieldToStore({\n  field,\n  value,\n  dataId,\n  context,\n}: {\n  field: FieldNode;\n  value: any;\n  dataId: string;\n  context: WriteContext;\n}) {\n  const { variables, dataIdFromObject, store } = context;\n\n  let storeValue: StoreValue;\n  let storeObject: StoreObject;\n\n  const storeFieldName: string = storeKeyNameFromField(field, variables);\n  // specifies if we need to merge existing keys in the store\n  let shouldMerge = false;\n  // If we merge, this will be the generatedKey\n  let generatedKey: string = '';\n\n  // If this is a scalar value...\n  if (!field.selectionSet || value === null) {\n    storeValue =\n      value != null && typeof value === 'object'\n        ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n          // an id.\n          { type: 'json', json: value }\n        : // Otherwise, just store the scalar directly in the store.\n          value;\n  } else if (Array.isArray(value)) {\n    const generatedId = `${dataId}.${storeFieldName}`;\n\n    storeValue = processArrayValue(\n      value,\n      generatedId,\n      field.selectionSet,\n      context,\n    );\n  } else {\n    // It's an object\n    let valueDataId = `${dataId}.${storeFieldName}`;\n    let generated = true;\n\n    // We only prepend the '$' if the valueDataId isn't already a generated\n    // id.\n    if (!isGeneratedId(valueDataId)) {\n      valueDataId = '$' + valueDataId;\n    }\n\n    if (dataIdFromObject) {\n      const semanticId = dataIdFromObject(value);\n\n      // We throw an error if the first character of the id is '$. This is\n      // because we use that character to designate an Apollo-generated id\n      // and we use the distinction between user-desiginated and application-provided\n      // ids when managing overwrites.\n      if (semanticId && isGeneratedId(semanticId)) {\n        throw new Error(\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n      }\n\n      if (semanticId) {\n        valueDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(valueDataId, field, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: valueDataId,\n        result: value,\n        selectionSet: field.selectionSet,\n        context,\n      });\n    }\n\n    // We take the id and escape it (i.e. wrap it with an enclosing object).\n    // This allows us to distinguish IDs from normal scalars.\n    const typename = value.__typename;\n    storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n    // check if there was a generated id at the location where we're\n    // about to place this new id. If there was, we have to merge the\n    // data from that id with the data we're about to write in the store.\n    storeObject = store.get(dataId);\n    const escapedId =\n      storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n    if (escapedId !== storeValue && isIdValue(escapedId)) {\n      const hadTypename = escapedId.typename !== undefined;\n      const hasTypename = typename !== undefined;\n      const typenameChanged =\n        hadTypename && hasTypename && escapedId.typename !== typename;\n\n      // If there is already a real id in the store and the current id we\n      // are dealing with is generated, we throw an error.\n      // One exception we allow is when the typename has changed, which occurs\n      // when schema defines a union, both with and without an ID in the same place.\n      // checks if we \"lost\" the read id\n      if (generated && !escapedId.generated && !typenameChanged) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided id` +\n            ` but the store already contains an id of ${\n              escapedId.id\n            } for this object. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n      // checks if we \"lost\" the typename\n      if (hadTypename && !hasTypename) {\n        throw new Error(\n          `Store error: the application attempted to write an object with no provided typename` +\n            ` but the store already contains an object with typename of ${\n              escapedId.typename\n            } for the object of id ${escapedId.id}. The selectionSet` +\n            ` that was trying to be written is:\\n` +\n            print(field),\n        );\n      }\n\n      if (escapedId.generated) {\n        generatedKey = escapedId.id;\n        // we should only merge if it's an object of the same type\n        // otherwise, we should delete the generated object\n        if (typenameChanged) {\n          store.delete(generatedKey);\n        } else {\n          shouldMerge = true;\n        }\n      }\n    }\n  }\n\n  const newStoreObj = {\n    ...store.get(dataId),\n    [storeFieldName]: storeValue,\n  } as StoreObject;\n\n  if (shouldMerge) {\n    mergeWithGenerated(generatedKey, (storeValue as IdValue).id, store);\n  }\n\n  storeObject = store.get(dataId);\n  if (!storeObject || storeValue !== storeObject[storeFieldName]) {\n    store.set(dataId, newStoreObj);\n  }\n}\n\nfunction processArrayValue(\n  value: any[],\n  generatedId: string,\n  selectionSet: SelectionSetNode,\n  context: WriteContext,\n): any[] {\n  return value.map((item: any, index: any) => {\n    if (item === null) {\n      return null;\n    }\n\n    let itemDataId = `${generatedId}.${index}`;\n\n    if (Array.isArray(item)) {\n      return processArrayValue(item, itemDataId, selectionSet, context);\n    }\n\n    let generated = true;\n\n    if (context.dataIdFromObject) {\n      const semanticId = context.dataIdFromObject(item);\n\n      if (semanticId) {\n        itemDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: itemDataId,\n        result: item,\n        selectionSet,\n        context,\n      });\n    }\n\n    return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n  });\n}\n","import graphqlAnywhere, { Resolver, ExecInfo } from 'graphql-anywhere';\n\nimport {\n  IdValue,\n  assign,\n  isEqual,\n  getDefaultValues,\n  getQueryDefinition,\n  isJsonValue,\n  isIdValue,\n  toIdValue,\n  getStoreKeyName,\n} from 'apollo-utilities';\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadQueryOptions,\n  IdValueWithPreviousResult,\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n} from './types';\n\n/**\n * The key which the cache id for a given value is stored in the result object. This key is private\n * and should not be used by Apollo client users.\n *\n * Uses a symbol if available in the environment.\n *\n * @private\n */\nexport const ID_KEY = typeof Symbol !== 'undefined' ? Symbol('id') : '@@id';\n\n/**\n * Resolves the result of a query solely from the store (i.e. never hits the server).\n *\n * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n * store.\n *\n * @param {DocumentNode} query The query document to resolve from the data available in the store.\n *\n * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n * be referenced by the query document.\n *\n * @param {any} previousResult The previous result returned by this function for the same query.\n * If nothing in the store changed since that previous result then values from the previous result\n * will be returned to preserve referential equality.\n */\nexport function readQueryFromStore<QueryType>(\n  options: ReadQueryOptions,\n): QueryType {\n  const optsPatch = { returnPartialData: false };\n\n  return diffQueryAgainstStore<QueryType>({\n    ...options,\n    ...optsPatch,\n  }).result;\n}\n\nconst readStoreResolver: Resolver = (\n  fieldName: string,\n  idValue: IdValueWithPreviousResult,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n) => {\n  assertIdValue(idValue);\n\n  const objId = idValue.id;\n  const obj = context.store.get(objId);\n  const storeKeyName = getStoreKeyName(fieldName, args, directives);\n  let fieldValue = (obj || {})[storeKeyName];\n\n  if (typeof fieldValue === 'undefined') {\n    if (\n      context.cacheRedirects &&\n      obj &&\n      (obj.__typename || objId === 'ROOT_QUERY')\n    ) {\n      const typename = obj.__typename || 'Query';\n\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(obj, args, {\n            getCacheKey: (obj: { __typename: string; id: string | number }) =>\n              toIdValue({\n                id: context.dataIdFromObject(obj),\n                typename: obj.__typename,\n              }),\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    if (!context.returnPartialData) {\n      throw new Error(\n        `Can't find field ${storeKeyName} on object (${objId}) ${JSON.stringify(\n          obj,\n          null,\n          2,\n        )}.`,\n      );\n    }\n\n    context.hasMissingField = true;\n\n    return fieldValue;\n  }\n\n  // if this is an object scalar, it must be a json blob and we have to unescape it\n  if (isJsonValue(fieldValue)) {\n    // If the JSON blob is the same now as in the previous result, return the previous result to\n    // maintain referential equality.\n    //\n    // `isEqual` will first perform a referential equality check (with `===`) in case the JSON\n    // value has not changed in the store, and then a deep equality check if that fails in case a\n    // new JSON object was returned by the API but that object may still be the same.\n    if (\n      idValue.previousResult &&\n      isEqual(idValue.previousResult[resultKey], fieldValue.json)\n    ) {\n      return idValue.previousResult[resultKey];\n    }\n    return fieldValue.json;\n  }\n\n  // If we had a previous result, try adding that previous result value for this field to our field\n  // value. This will create a new value without mutating the old one.\n  if (idValue.previousResult) {\n    fieldValue = addPreviousResultToIdValues(\n      fieldValue,\n      idValue.previousResult[resultKey],\n    );\n  }\n\n  return fieldValue;\n};\n\n/**\n * Given a store and a query, return as much of the result as possible and\n * identify if any data was missing from the store.\n * @param  {DocumentNode} query A parsed GraphQL query document\n * @param  {Store} store The Apollo Client store object\n * @param  {any} previousResult The previous result returned by this function for the same query\n * @return {result: Object, complete: [boolean]}\n */\nexport function diffQueryAgainstStore<T>({\n  store,\n  query,\n  variables,\n  previousResult,\n  returnPartialData = true,\n  rootId = 'ROOT_QUERY',\n  fragmentMatcherFunction,\n  config,\n}: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n  // Throw the right validation error by trying to find a query in the document\n  const queryDefinition = getQueryDefinition(query);\n\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  const context: ReadStoreContext = {\n    // Global settings\n    store,\n    returnPartialData,\n    dataIdFromObject: (config && config.dataIdFromObject) || null,\n    cacheRedirects: (config && config.cacheRedirects) || {},\n    // Flag set during execution\n    hasMissingField: false,\n  };\n\n  const rootIdValue = {\n    type: 'id',\n    id: rootId,\n    previousResult,\n  };\n\n  const result = graphqlAnywhere(\n    readStoreResolver,\n    query,\n    rootIdValue,\n    context,\n    variables,\n    {\n      fragmentMatcher: fragmentMatcherFunction,\n      resultMapper,\n    },\n  );\n\n  return {\n    result,\n    complete: !context.hasMissingField,\n  };\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  if (!isIdValue(idValue)) {\n    throw new Error(`Encountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n  }\n}\n\n/**\n * Adds a previous result value to id values in a nested array. For a single id value and a single\n * previous result then the previous value is added directly.\n *\n * For arrays we put all of the ids from the previous result array in a map and add them to id\n * values with the same id.\n *\n * This function does not mutate. Instead it returns new instances of modified values.\n *\n * @private\n */\nfunction addPreviousResultToIdValues(value: any, previousResult: any): any {\n  // If the value is an `IdValue`, add the previous result to it whether or not that\n  // `previousResult` is undefined.\n  //\n  // If the value is an array, recurse over each item trying to add the `previousResult` for that\n  // item.\n  if (isIdValue(value)) {\n    return {\n      ...value,\n      previousResult,\n    };\n  } else if (Array.isArray(value)) {\n    const idToPreviousResult: Map<string, any> = new Map();\n\n    // If the previous result was an array, we want to build up our map of ids to previous results\n    // using the private `ID_KEY` property that is added in `resultMapper`.\n    if (Array.isArray(previousResult)) {\n      previousResult.forEach(item => {\n        // item can be null\n        if (item && item[ID_KEY]) {\n          idToPreviousResult.set(item[ID_KEY], item);\n          // idToPreviousResult[item[ID_KEY]] = item;\n        }\n      });\n    }\n\n    // For every value we want to add the previous result.\n    return value.map((item, i) => {\n      // By default the previous result for this item will be in the same array position as this\n      // item.\n      let itemPreviousResult = previousResult && previousResult[i];\n\n      // If the item is an id value, we should check to see if there is a previous result for this\n      // specific id. If there is, that will be the value for `itemPreviousResult`.\n      if (isIdValue(item)) {\n        itemPreviousResult =\n          idToPreviousResult.get(item.id) || itemPreviousResult;\n      }\n\n      return addPreviousResultToIdValues(item, itemPreviousResult);\n    });\n  }\n  // Return the value, nothing changed.\n  return value;\n}\n\n/**\n * Maps a result from `graphql-anywhere` to a final result value.\n *\n * If the result and the previous result from the `idValue` pass a shallow equality test, we just\n * return the `previousResult` to maintain referential equality.\n *\n * We also add a private id property to the result that we can use later on.\n *\n * @private\n */\nfunction resultMapper(resultFields: any, idValue: IdValueWithPreviousResult) {\n  // If we had a previous result, we may be able to return that and preserve referential equality\n  if (idValue.previousResult) {\n    const currentResultKeys = Object.keys(resultFields);\n\n    const sameAsPreviousResult =\n      // Confirm that we have the same keys in both the current result and the previous result.\n      Object.keys(idValue.previousResult).every(\n        key => currentResultKeys.indexOf(key) > -1,\n      ) &&\n      // Perform a shallow comparison of the result fields with the previous result. If all of\n      // the shallow fields are referentially equal to the fields of the previous result we can\n      // just return the previous result.\n      //\n      // While we do a shallow comparison of objects, but we do a deep comparison of arrays.\n      currentResultKeys.every(key =>\n        areNestedArrayItemsStrictlyEqual(\n          resultFields[key],\n          idValue.previousResult[key],\n        ),\n      );\n\n    if (sameAsPreviousResult) {\n      return idValue.previousResult;\n    }\n  }\n\n  // Add the id to the result fields. It should be non-enumerable so users can’t see it without\n  // trying very hard.\n  Object.defineProperty(resultFields, ID_KEY, {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: idValue.id,\n  });\n\n  return resultFields;\n}\n\ntype NestedArray<T> = T | Array<T | Array<T | Array<T>>>;\n\n/**\n * Compare all the items to see if they are all referentially equal in two arrays no matter how\n * deeply nested the arrays are.\n *\n * @private\n */\nfunction areNestedArrayItemsStrictlyEqual(\n  a: NestedArray<any>,\n  b: NestedArray<any>,\n): boolean {\n  // If `a` and `b` are referentially equal, return true.\n  if (a === b) {\n    return true;\n  }\n  // If either `a` or `b` are not an array or not of the same length return false. `a` and `b` are\n  // known to not be equal here, we checked above.\n  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) {\n    return false;\n  }\n  // Otherwise let us compare all of the array items (which are potentially nested arrays!) to see\n  // if they are equal.\n  return a.every((item, i) => areNestedArrayItemsStrictlyEqual(item, b[i]));\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class RecordingCache implements NormalizedCache {\n  constructor(private readonly data: NormalizedCacheObject = {}) {}\n\n  private recordedData: NormalizedCacheObject = {};\n\n  public record(\n    transaction: (recordingCache: RecordingCache) => void,\n  ): NormalizedCacheObject {\n    transaction(this);\n    const recordedData = this.recordedData;\n    this.recordedData = {};\n    return recordedData;\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data, ...this.recordedData };\n  }\n\n  public get(dataId: string): StoreObject {\n    if (this.recordedData.hasOwnProperty(dataId)) {\n      // recording always takes precedence:\n      return this.recordedData[dataId];\n    }\n    return this.data[dataId];\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    if (this.get(dataId) !== value) {\n      this.recordedData[dataId] = value;\n    }\n  }\n\n  public delete(dataId: string): void {\n    this.recordedData[dataId] = undefined;\n  }\n\n  public clear(): void {\n    Object.keys(this.data).forEach(dataId => this.delete(dataId));\n    this.recordedData = {};\n  }\n\n  public replace(newData: NormalizedCacheObject): void {\n    this.clear();\n    this.recordedData = { ...newData };\n  }\n}\n\nexport function record(\n  startingState: NormalizedCacheObject,\n  transaction: (recordingCache: RecordingCache) => void,\n): NormalizedCacheObject {\n  const recordingCache = new RecordingCache(startingState);\n  return recordingCache.record(transaction);\n}\n","import { DocumentNode } from 'graphql';\n\nimport { Cache, DataProxy, ApolloCache, Transaction } from 'apollo-cache';\n\nimport {\n  getFragmentQueryDocument,\n  addTypenameToDocument,\n} from 'apollo-utilities';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  OptimisticStoreItem,\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\nimport { writeResultToStore } from './writeToStore';\nimport { readQueryFromStore, diffQueryAgainstStore } from './readFromStore';\nimport { defaultNormalizedCacheFactory } from './objectCache';\nimport { record } from './recordingCache';\nconst defaultConfig: ApolloReducerConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  storeFactory: defaultNormalizedCacheFactory,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  protected data: NormalizedCache;\n  protected config: ApolloReducerConfig;\n  protected optimistic: OptimisticStoreItem[] = [];\n  private watches: Cache.WatchOptions[] = [];\n  private addTypename: boolean;\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: ApolloReducerConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      console.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      console.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = this.config.addTypename;\n    this.data = this.config.storeFactory();\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    if (optimistic && this.optimistic.length > 0) {\n      const patches = this.optimistic.map(opt => opt.data);\n      return Object.assign({}, this.data.toObject(), ...patches);\n    }\n\n    return this.data.toObject();\n  }\n\n  public read<T>(query: Cache.ReadOptions): T | null {\n    if (query.rootId && this.data.get(query.rootId) === undefined) {\n      return null;\n    }\n\n    return readQueryFromStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      rootId: query.rootId,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      previousResult: query.previousResult,\n      config: this.config,\n    });\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    return diffQueryAgainstStore({\n      store: this.config.storeFactory(this.extract(query.optimistic)),\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction: this.config.fragmentMatcher.match,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.push(watch);\n\n    return () => {\n      this.watches = this.watches.filter(c => c !== watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new Error(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(id: string) {\n    // Throw away optimistic changes of that particular mutation\n    const toPerform = this.optimistic.filter(item => item.id !== id);\n\n    this.optimistic = [];\n\n    // Re-run all of our optimistic data actions on top of one another.\n    toPerform.forEach(change => {\n      this.recordOptimisticTransaction(change.transaction, change.id);\n    });\n\n    this.broadcastWatches();\n  }\n\n  public performTransaction(transaction: Transaction<NormalizedCacheObject>) {\n    // TODO: does this need to be different, or is this okay for an in-memory cache?\n\n    let alreadySilenced = this.silenceBroadcast;\n    this.silenceBroadcast = true;\n\n    transaction(this);\n\n    if (!alreadySilenced) {\n      // Don't un-silence since this is a nested transaction\n      // (for example, a transaction inside an optimistic record)\n      this.silenceBroadcast = false;\n    }\n\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    this.silenceBroadcast = true;\n\n    const patch = record(this.extract(true), recordingCache => {\n      // swapping data instance on 'this' is currently necessary\n      // because of the current architecture\n      const dataCache = this.data;\n      this.data = recordingCache;\n      this.performTransaction(transaction);\n      this.data = dataCache;\n    });\n\n    this.optimistic.push({\n      id,\n      transaction,\n      data: patch,\n    });\n\n    this.silenceBroadcast = false;\n\n    this.broadcastWatches();\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) return addTypenameToDocument(document);\n    return document;\n  }\n\n  public readQuery<QueryType>(\n    options: DataProxy.Query,\n    optimistic: boolean = false,\n  ): QueryType {\n    return this.read({\n      query: options.query,\n      variables: options.variables,\n      optimistic,\n    });\n  }\n\n  public readFragment<FragmentType>(\n    options: DataProxy.Fragment,\n    optimistic: boolean = false,\n  ): FragmentType | null {\n    return this.read({\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery(options: DataProxy.WriteQueryOptions): void {\n    this.write({\n      dataId: 'ROOT_QUERY',\n      result: options.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n    });\n  }\n\n  public writeFragment(options: DataProxy.WriteFragmentOptions): void {\n    this.write({\n      dataId: options.id,\n      result: options.data,\n      query: this.transformDocument(\n        getFragmentQueryDocument(options.fragment, options.fragmentName),\n      ),\n      variables: options.variables,\n    });\n  }\n\n  protected broadcastWatches() {\n    // Skip this when silenced (like inside a transaction)\n    if (this.silenceBroadcast) return;\n\n    // right now, we invalidate all queries whenever anything changes\n    this.watches.forEach((c: Cache.WatchOptions) => {\n      const newData = this.diff({\n        query: c.query,\n        variables: c.variables,\n\n        // TODO: previousResult isn't in the types - this will only work\n        // with ObservableQuery which is in a different package\n        previousResult: (c as any).previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      });\n\n      c.callback(newData);\n    });\n  }\n}\n"],"names":["isTest","warnOnceInDevelopment","print","getQueryDefinition","assign","getDefaultValues","getOperationDefinition","createFragmentMap","getFragmentDefinitions","shouldInclude","isField","resultKeyNameFromField","isProduction","isInlineFragment","toIdValue","isIdValue","storeKeyNameFromField","getStoreKeyName","isJsonValue","isEqual","__extends","addTypenameToDocument","getFragmentQueryDocument","ApolloCache"],"mappings":"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"}